#include <iostream>
#include <vector>
#include <string>

#define DWORDMAX 0xffffffff
#define WORDMAX  0xffff
#define BYTEMAX  0xff

#define CLEAR_HEAD 0xfe
#define STORE_IN_MEM 0x13
#define REINIT_8BYTES 0x0e
#define XOR_WITH_17 0x0a
#define COMPARE_FLAG_SYM 0x14
#define ADD 0x18 
#define SUB 0x17
#define XOR 0x16
#define CHECK_FLAG_REG 0xDE

typedef unsigned short int WORD;
typedef unsigned int DWORD;

class VMChecker {
private:
	std::string flag;
	std::vector<DWORD> code;

public:
	VMChecker( std::string _flag );
	void SetCheckerCode( std::vector<DWORD> _code );
	bool Check( void );
};

VMChecker::VMChecker( std::string _flag )
{
	flag = _flag;
};

void VMChecker::SetCheckerCode( std::vector<DWORD> _code )
{
	code = _code;
};

bool VMChecker::Check()
{
	int ip = 128;
	int stack_pointer = 0x0;
	int flag_correct_syms = 0;

	std::vector<DWORD> stack;
		
	// init stack with 0
	for ( int i = 0; i < 0x100; i++ )
		stack.push_back( 0x0 );

	// for ( int i = 0; i < code.size(); i++ )
	// {
	// 	std::cout << "code[" << i << "]=" << code[i] << std::endl;
	// }

	while ( 1 )
	{
		// get instruction

		DWORD instr = code[ ip ];

		unsigned char cmd;
		cmd = instr >> 24;

		switch ( cmd )
		{
			case STORE_IN_MEM:
			{
				WORD addr = instr & 0xffff;
				code[ addr ] = (instr >> 16) & 0xff;
				break;
			}
			case REINIT_8BYTES:
			{
				if ( instr == 0x0e0e0e0e )
				{
					for ( int i = 0; i < 8; i++ )
					{
						code[ i ] ^= 0x13;
					} 
				}

				break;
			}
			case XOR_WITH_17:
			{
				WORD addr = instr & 0xffff;
				code[ addr ] ^= 0x17;
				break;
			}
			case COMPARE_FLAG_SYM:
			{
				WORD addr = instr & 0xffff;
				char flag_addr = (instr>>16)&0xff;

				//std::cout << "code[ addr ] = " << code[ addr ] << "flag[ flag_addr ] = " << flag[ flag_addr ] << std::endl;

				if ( code[ addr ] == flag[ flag_addr ] )
				{
					flag_correct_syms++;
				}

				break;
			}
			case ADD:
			{
				WORD addr = instr & 0xffff;
				char value = (instr>>16)&0xff;
				code[ addr ] += value;

				break;
			}
			case CLEAR_HEAD:
			{
				for ( int i = 0; i < 8; i++ )
				{
					code[ i ] = 0xfe;
				}

				break;
			}
			case SUB:
			{
				WORD addr = instr & 0xffff;
				char value = (instr>>16)&0xff;
				code[ addr ] -= value;
				
				break;
			}
			case XOR:
			{
				WORD addr = instr & 0xffff;
				char value = (instr>>16) & 0xff;
				code[ addr ] ^= value;

				break;
			}
			case CHECK_FLAG_REG:
			{
				char value = (instr>>16)&0xff;

				//std::cout<< "flag_correct_syms: " << flag_correct_syms << std::endl;

				if ( flag_correct_syms == value )
				{
					return true;
				}
				else
				{
					return false;
				}

				break;
			}
		}

		ip++;
	}
};

bool check_lastbytes( std::string flag ); 
bool check21_24bytes( std::string flag );
bool check17_20bytes( std::string flag );
bool check12byte( std::string flag );
bool checkfirst2bytes( std::string flag );
void printRandomDataBlock( void );
bool checkStopKey( void );

DWORD flag_format_checker[] = {4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 323289088, 326041601, 328859650, 335478787, 329973764, 322371589, 320012294, 334102535, 235802126, 324403202, 184418306, 335544322, 334495752, 330956809, 334364682, 329252875, 328728588, 319946760, 320405517, 331415566, 235802126, 180027400, 408944648, 335609864, 318832640, 319094788, 320471048, 333053964, 318898177, 319160325, 320536585, 333119501, 318963714, 319225862, 320602122, 333185038, 319029251, 319291399, 320667659, 333316111, 235802126, 402718720, 403243008, 403308545, 408289280, 335675392, 235802126, 4278124286, 235802126, 394133508, 335740932, 318767111, 373227527, 371130375, 370278407, 376897543, 385810439, 382009351, 386138119, 335806471, 3724918511};
DWORD flag_check_9_11_syms[] = {4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 235802126, 4278124286, 235802126, 4278124286, 318767104, 318767105, 318767106, 318767107, 318767108, 335478789, 335413254, 335347719, 235802126, 323289090, 370343938, 370671618, 385744898, 376897538, 378077186, 385744898, 378077186, 336134146, 386400258, 336199682, 403111938, 336265218, 235802126, 4278124286, 3724790526};
DWORD flag_check_13_16_syms[] = {4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 319881216, 319881217, 319881218, 319881219, 319946756, 319946757, 319946758, 319946759, 320012296, 320012297, 320012298, 320012299, 403701768, 403832840, 336396296, 386138120, 336461832, 405995528, 336527368, 389152776, 336592904, 235802126, 4278124286, 235802126, 4278124286, 235802126, 4278124286, 235802126, 3724851902};
DWORD flag_check_25_31_syms[] = {4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4278124286, 4278124286, 4278124286, 4278124286, 235802126, 235802126, 235802126, 235802126, 4278185967, 4025479151, 4009688830, 4278124286, 318767104, 318832641, 318898178, 318963715, 319029252, 319094789, 319160326, 319225863, 370409472, 403898368, 403832832, 337182720, 416284673, 395968513, 337248257, 402718721, 337313793, 386072577, 337379329, 385941505, 337444865, 402718721, 337510401, 369360897, 337575937, 4278124286, 235802126, 235802126, 235802126, 4278124286, 3725065982, 4278124286, 235802126, 235802126, 235802126, 235802126, 235802126, 235802126, 235802126, 235802126, 318767105, 318832642, 318963712, 318767104, 235802126};

// Aero{3135918651d26f55292d9785451d8aa8}
// flag - Aero{3135 +
// 918 - 9 10 11 +
// 6 - 12  +
// 51d2 - 13 14 15 16 +  
// 6f55 - 17 18 19 20 +
// 292d - 21 22 23 24 +
// 9785451 - 25 26 27 28 29 30 31 + 
// d8aa8} - 32 33 34 35 36 37 

int main( int argc, char* argv[], char* envp[] )
{
	while ( !checkStopKey() ) 
	{
		printRandomDataBlock();
		std::cout << std::endl;
		std::cout << "[-] Error key! Start of self-destruction!" << std::endl;
	}

	std::cout << "[+] Key is valid!" << std::endl;

	return 0;
};

bool check_lastbytes( std::string flag )
{
	unsigned char val1 = flag[ 32 ];
	unsigned char val2 = flag[ 33 ];
	unsigned char val3 = flag[ 34 ];
	unsigned char val4 = flag[ 35 ];
	unsigned char val5 = flag[ 36 ];
	unsigned char val6 = flag[ 37 ];

	if ( val6 != '}' ) return false;
	if ( val2 != val5 ) return false;
	if ( val3 != val4 ) return false;
	if ( val1 != 'd' ) return false;
	if ( ( val3 - val2 ) != 41 ) return false;
	if ( ( val3 ^ val2 ) != 89 ) return false;
	if ( ( val3 + val2 ) != 153 ) return false;

	return true; 
};

bool check21_24bytes( std::string flag )
{
	if ( flag[ 21 ] != '2' ) return false;
	if ( flag[ 22 ] != '9' ) return false;
	if ( flag[ 23 ] != '2' ) return false;
	if ( flag[ 24 ] != 'd' ) return false;

	return true;
};

bool check17_20bytes( std::string flag )
{
	int values[ 4 ] = { flag[ 17 ], flag[ 18 ], flag[ 19 ], flag[ 20 ] };

	if ( ( values[ 3 ] + values[ 2 ] ) != 106 )
		return false;

	if ( ( values[ 0 ] - values[ 2 ] ) != 1 )
		return false;

	if ( ( values[ 1 ] != 'f' ) )
		return false;

	if ( values[ 0 ] != '6' )
		return false;

	return true;
};

bool check12byte( std::string flag )
{
	int m_next = ( 0x1337 * 0x1337 + 0x3117 ) % 0xffff;

	for ( int i = 0; i < 1000; i++ )
	{
		m_next = ( 0x1337 * m_next + 0x3117 ) % 0xffff;
	}

	char xor_key = m_next & 0xff;

	//std::cout << int( flag[ 12 ] ^ xor_key ) << std::endl;

	return (flag[ 12 ] ^ xor_key) == 56 ;
};

bool check4bytes( std::string flag )
{
	char elem_1 = flag[ 5 ];
	char elem_2 = flag[ 6 ];

	char elem1 = flag[ 7 ];
	char elem2 = flag[ 8 ];

	int value1 = 0;
	int value2 = 0;

	value1  = ( elem1 - '0' ) * 10;
	value1 += ( elem2 - '0' );

	value2  = ( elem_1 - '0' ) * 10;
	value2 += ( elem_2 - '0' );

	return (value1 ^ value2) == 60;
}

bool check2bytes( std::string flag )
{
	char elem1 = flag[ 7 ];
	char elem2 = flag[ 8 ];

	int value = 0;

	value  = ( elem1 - '0' ) * 10;
	value += ( elem2 - '0' );

	return value == 35;
}

void printRandomDataBlock( void )
{
	FILE *fp = fopen( "/dev/urandom", "r" );
	char buffer[ 128 ];
	fread( buffer, 1, 128 ,fp );
	fclose( fp );

	for ( int i = 0; i < 128; i++ ) {
		std::cout << std::hex << (int)buffer[ i ];
	}
};


bool checkStopKey( void )
{
	std::string flag;
	
	std::cout << "[?] Enter the key: ";
	std::cin >> flag;

	if ( flag.size() != 38 )
		return false;

	VMChecker check_flag = VMChecker( flag );

	std::vector<DWORD> format_check;

	for ( int i = 0; i < 189; i++ )
	{
		format_check.push_back( flag_format_checker[ i ] );
	}

	check_flag.SetCheckerCode( format_check );
	int total_checks = 0;

	total_checks += check_flag.Check();
	total_checks += check2bytes( flag );
	total_checks += check4bytes( flag );
	total_checks += check12byte( flag );
	total_checks += check17_20bytes( flag );
	total_checks += check21_24bytes( flag );

	std::vector<DWORD> format_check_1;
	std::vector<DWORD> format_check_2;
	std::vector<DWORD> format_check_3;

	for ( int i = 0; i < 157; i++ )
	{
		format_check_1.push_back( flag_check_9_11_syms[ i ] );
		format_check_2.push_back( flag_check_13_16_syms[ i ] );
	}

	for ( int i = 0; i < 185; i++ )
	{
		format_check_3.push_back( flag_check_25_31_syms[ i ] );
	}

	check_flag.SetCheckerCode( format_check_1 );
	total_checks += check_flag.Check();
	check_flag.SetCheckerCode( format_check_2 );
	total_checks += check_flag.Check();
	check_flag.SetCheckerCode( format_check_3 );
	total_checks += check_flag.Check();

	total_checks += check_lastbytes( flag );

	//std::cout << "total_checks = " << total_checks << std::endl;
	
	if ( total_checks == 10 )
	{
		return true;
	}
	else
	{
		return false;
	}

	return true;
};